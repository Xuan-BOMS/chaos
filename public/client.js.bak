// 建立 Socket.io 连接
const socket = io();

// 游戏配置
const GRID_SIZE = 5;
const CELL_PADDING = 0.15; // 增加格子内边距，让棋子更小巧
let board = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
let hoveredCell = null;
let isFlipping = false; // 硬币是否正在翻转
let isMyTurn = false; // 是否是当前玩家的回合
let currentRoom = null; // 当前房间ID
let playerCount = 0; // 当前房间的玩家数量

// 界面元素
const matchingScreen = document.getElementById('matchingScreen');
const gameScreen = document.getElementById('gameScreen');
const matchingStatus = document.getElementById('matchingStatus');
const roomInput = document.getElementById('roomInput');
const roomIdInput = document.getElementById('roomIdInput');
const roomActionBtn = document.getElementById('roomActionBtn');
const canvas = document.getElementById('gameBoard');
const ctx = canvas.getContext('2d');

// 游戏配置
const GRID_SIZE = 5;
const CELL_PADDING = 0.15; // 增加格子内边距，让棋子更小巧
let board = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
let hoveredCell = null;
let isFlipping = false; // 硬币是否正在翻转
let isMyTurn = false; // 是否是当前玩家的回合
let currentRoom = null; // 当前房间ID
let playerCount = 0; // 当前房间的玩家数量

// 界面元素
const matchingScreen = document.getElementById('matchingScreen');
const gameScreen = document.getElementById('gameScreen');
const matchingStatus = document.getElementById('matchingStatus');
const roomInput = document.getElementById('roomInput');
const roomIdInput = document.getElementById('roomIdInput');
const roomActionBtn = document.getElementById('roomActionBtn');
const canvas = document.getElementById('gameBoard');
const ctx = canvas.getContext('2d');

// 调试函数
function logGameState(event) {
    console.log(`[${event}] 游戏状态:`, {
        playerCount,
        isMyTurn,
        currentRoom
    });
}

// 处理棋盘更新
// Socket.io 事件处理
socket.on('matchingStatus', (status) => {
    matchingStatus.textContent = status;
});

socket.on('roomError', (error) => {
    alert(error);
});

socket.on('roomCreated', (roomId) => {
    currentRoom = roomId;
    playerCount = 1; // 创建房间时设置为1个玩家
    matchingStatus.textContent = '等待其他玩家加入...';
    hideRoomInput();
});

socket.on('matchSuccess', ({ roomId, isFirstPlayer }) => {
    currentRoom = roomId;
    isMyTurn = isFirstPlayer;
    playerCount = 2; // 匹配成功时设置玩家数量为2
    logGameState('matchSuccess');
    showGameScreen();
    updateTurnButton();
});

socket.on('gameStart', ({ board: newBoard, currentTurn, playerCount: count }) => {
    board = JSON.parse(JSON.stringify(newBoard));
    isMyTurn = (currentTurn === socket.id);
    playerCount = count || 2; // 使用服务器发送的玩家数量，如果没有则默认为2
    console.log('游戏开始:', { isMyTurn, playerCount, currentTurn });
    
    showGameScreen();
    // 确保游戏界面完全显示后再初始化画布
    setTimeout(() => {
        resizeCanvas();
        updateTurnButton();
    }, 100);
});

socket.on('updateGame', ({ board: newBoard, currentTurn }) => {
    board = JSON.parse(JSON.stringify(newBoard));
    isMyTurn = (currentTurn === socket.id);
    logGameState('updateGame');
    updateTurnButton();
    drawBoard();
});

socket.on('playerLeft', () => {
    alert('对方已离开游戏');
    playerCount = 1;
    showMatchingScreen();
});

// UI 辅助函数
function showMatchingScreen() {
    matchingScreen.style.display = 'block';
    gameScreen.style.display = 'none';
    currentRoom = null;
    playerCount = 1; // 重置玩家数量
    board = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
    matchingStatus.textContent = '';
    hideRoomInput();
}

function showGameScreen() {
    matchingScreen.style.display = 'none';
    gameScreen.style.display = 'block';
    // 在显示游戏界面后立即调整画布大小
    setTimeout(() => {
        resizeCanvas();
    }, 0);
}

function showRoomInput(action) {
    roomInput.style.display = 'flex';
    roomActionBtn.textContent = action === 'create' ? '创建房间' : '加入房间';
    roomActionBtn.dataset.action = action;
    roomIdInput.value = '';
    roomIdInput.placeholder = action === 'create' ? '请输入要创建的房间号' : '请输入要加入的房间号';
}

function hideRoomInput() {
    roomInput.style.display = 'none';
}

// 处理初始化玩家
socket.on('initPlayer', ({ isFirstPlayer }) => {
    isMyTurn = isFirstPlayer;
    updateTurnButton();
});

// 更新回合按钮状态
function updateTurnButton() {
    const endTurnBtn = document.getElementById('endTurnBtn');
    if (!endTurnBtn) return;

    if (playerCount >= 2) {
        if (isMyTurn) {
            endTurnBtn.textContent = '回合结束';
            endTurnBtn.disabled = false;
            endTurnBtn.classList.remove('disabled');
        } else {
            endTurnBtn.textContent = '对方回合';
            endTurnBtn.disabled = true;
            endTurnBtn.classList.add('disabled');
        }
    } else {
        endTurnBtn.textContent = '等待其他玩家...';
        endTurnBtn.disabled = true;
        endTurnBtn.classList.add('disabled');
    }
}
}

// 等待 DOM 加载完成后初始化
// 等待 DOM 加载完成后初始化
document.addEventListener('DOMContentLoaded', () => {
    try {
        initMatchingSystem();
        initGameControls();
    } catch (error) {
        console.error('初始化出错:', error);
    }
});

// 初始化匹配系统
function initMatchingSystem() {
    // 随机匹配按钮
    document.getElementById('randomMatchBtn').addEventListener('click', () => {
        matchingStatus.textContent = '正在寻找对手...';
        socket.emit('randomMatch');
        hideRoomInput();
    });

    // 创建房间按钮
    document.getElementById('createRoomBtn').addEventListener('click', () => {
        showRoomInput('create');
    });

    // 加入房间按钮
    document.getElementById('joinRoomBtn').addEventListener('click', () => {
        showRoomInput('join');
    });

    // 返回按钮
    document.getElementById('backToMatchingBtn').addEventListener('click', () => {
        hideRoomInput();
    });

    // 房间操作按钮
    roomActionBtn.addEventListener('click', () => {
        const roomId = roomIdInput.value.trim();
        if (!roomId) {
            alert('请输入房间号');
            return;
        }
        
        const action = roomActionBtn.dataset.action;
        if (action === 'create') {
            socket.emit('createRoom', roomId);
        } else {
            socket.emit('joinRoom', roomId);
        }
    });

    // 创建房间按钮
    const createRoomBtn = document.getElementById('createRoomBtn');
    if (createRoomBtn) {
        createRoomBtn.addEventListener('click', () => {
            console.log('点击创建房间');
            showRoomInput('create');
        });
    }

    // 加入房间按钮
    const joinRoomBtn = document.getElementById('joinRoomBtn');
    if (joinRoomBtn) {
        joinRoomBtn.addEventListener('click', () => {
            console.log('点击加入房间');
            showRoomInput('join');
        });
    }

    // 返回按钮
    const backBtn = document.getElementById('backToMatchingBtn');
    if (backBtn) {
        backBtn.addEventListener('click', () => {
            console.log('点击返回');
            hideRoomInput();
        });
    }
}
        showRoomInput('create');
    });

    // 加入房间按钮
    document.getElementById('joinRoomBtn').addEventListener('click', () => {
        showRoomInput('join');
    });

    // 返回按钮
    document.getElementById('backToMatchingBtn').addEventListener('click', () => {
        hideRoomInput();
    });

    // 房间操作按钮
    roomActionBtn.addEventListener('click', () => {
        const roomId = roomIdInput.value.trim();
        if (!roomId) {
            alert('请输入房间号');
            return;
        }
        
        if (roomActionBtn.dataset.action === 'create') {
            socket.emit('createRoom', roomId);
        } else {
            socket.emit('joinRoom', roomId);
        }
    });
}

// 初始化游戏控制
function initGameControls() {
    // 回合结束按钮
    const endTurnBtn = document.getElementById('endTurnBtn');
    if (endTurnBtn) {
        endTurnBtn.addEventListener('click', () => {
            if (isMyTurn) {
                console.log('发送回合结束');
                socket.emit('endTurn', board);
                // 立即更新本地状态
                isMyTurn = false;
                updateTurnButton();
                drawBoard(); // 立即重绘棋盘
            }
        });
    }

    // 结束游戏按钮
    const resetGameBtn = document.getElementById('resetGameBtn');
    if (resetGameBtn) {
        resetGameBtn.addEventListener('click', () => {
            if (confirm('确定要结束当前游戏吗？')) {
                socket.emit('resetGame');
            }
        });
    }

    // 退出房间按钮
    const leaveGameBtn = document.getElementById('leaveGameBtn');
    if (leaveGameBtn) {
        leaveGameBtn.addEventListener('click', () => {
            if (confirm('确定要退出当前游戏吗？')) {
                socket.emit('leaveGame');
                showMatchingScreen();
            }
        });
    }
}

// 监听棋子放置事件来启用回合结束按钮
function enableTurnEnd() {
    const endTurnBtn = document.getElementById('endTurnBtn');
    if (endTurnBtn) {
        isMyTurn = true;
        endTurnBtn.classList.remove('disabled');
        endTurnBtn.textContent = '回合结束';
    }
}

// 颜色配置
const COLORS = {
    white: '#FFFFFF',
    green: '#32CD32',
    red: '#FF6347',
    blue: '#1E90FF',
    yellow: '#FFD700',
    darkgreen: '#006400',
    darkred: '#8B0000',
    darkblue: '#00008B',
    darkyellow: '#8B4513',
    greenred: '#CD5C5C',
    greenblue: '#4682B4',
    greenyellow: '#9ACD32',
    redblue: '#800080',
    redyellow: '#D04E00',
    blueyellow: '#ADFF2F',
    purple: '#8A2BE2',
    black: '#000000'
};

const COLOR_NAMES = {
    white: '白色',
    green: '风（绿色）',
    red: '火（红色）',
    blue: '水（蓝色）',
    yellow: '土（黄色）',
    darkgreen: '强化风（深绿色）',
    darkred: '强化火（深红色）',
    darkblue: '强化水（深蓝色）',
    darkyellow: '强化土（深黄色）',
    greenred: '风+火',
    greenblue: '风+水',
    greenyellow: '风+土',
    redblue: '火+水',
    redyellow: '火+土',
    blueyellow: '水+土',
    purple: '以太',
    black: '混沌'
};

// 获取DOM元素
const canvas = document.getElementById('gameBoard');
const ctx = canvas.getContext('2d');
const modal = document.querySelector('.piece-selector-modal');
const overlay = document.querySelector('.modal-overlay');
const pieceGrid = document.querySelector('.piece-grid');
let selectedCell = null;

// 初始化棋子选择器
function initPieceSelector() {
    // 创建棋子选项
    Object.entries(COLORS).forEach(([color, value]) => {
        const container = document.createElement('div');
        container.className = 'piece-container';

        const option = document.createElement('div');
        option.className = 'piece-option';
        option.style.backgroundColor = value;
        option.setAttribute('data-color', color);

        const label = document.createElement('div');
        label.className = 'piece-label';
        label.textContent = COLOR_NAMES[color];

        container.appendChild(option);
        container.appendChild(label);
        pieceGrid.appendChild(container);

        option.addEventListener('click', () => {
            placePiece(color);
            closeModal();
        });
    });

    // 设置移除棋子按钮事件
    document.querySelector('.remove-piece').addEventListener('click', () => {
        if (selectedCell) {
            removePiece();
        }
        closeModal();
    });

    // 设置取消按钮事件
    document.querySelector('.cancel-selection').addEventListener('click', closeModal);
}

// 调整画布大小
function resizeCanvas() {
    if (!canvas || !canvas.parentElement) {
        console.error('Canvas或其父元素不存在');
        return;
    }

    console.log('调整画布大小');
    const containerWidth = canvas.parentElement.clientWidth;
    const size = Math.min(containerWidth - 40, 600);
    
    canvas.style.width = `${size}px`;
    canvas.style.height = `${size}px`;
    canvas.width = size * window.devicePixelRatio;
    canvas.height = size * window.devicePixelRatio;
    
    ctx.setTransform(1, 0, 0, 1, 0, 0); // 重置变换
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    
    requestAnimationFrame(() => {
        drawBoard();
        console.log('画布重绘完成');
    });
}

// 获取鼠标在棋盘上的位置
function getBoardPosition(event) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const x = (event.clientX - rect.left) * scaleX;
    const y = (event.clientY - rect.top) * scaleY;
    const cellSize = canvas.width / GRID_SIZE;
    
    return {
        row: Math.floor(y / cellSize),
        col: Math.floor(x / cellSize),
        cellSize: cellSize
    };
}

// 显示选择器模态框
function showModal() {
    modal.style.display = 'block';
    overlay.style.display = 'block';
}

// 关闭选择器模态框
function closeModal() {
    modal.style.display = 'none';
    overlay.style.display = 'none';
    selectedCell = null;
}

// 硬币翻转功能
function flipCoin() {
    if (isFlipping) return;
    
    const coin = document.querySelector('.coin');
    isFlipping = true;
    coin.classList.add('flipping');
    
    setTimeout(() => {
        const isHeads = Math.random() < 0.5;
        coin.style.transform = `rotateY(${isHeads ? '0' : '180'}deg)`;
        isFlipping = false;
        coin.classList.remove('flipping');
    }, 600);
}

// 绘制棋盘
function drawBoard() {
    console.log('绘制棋盘，当前状态:', JSON.stringify(board));
    const width = canvas.width / window.devicePixelRatio;
    const height = canvas.height / window.devicePixelRatio;
    const cellSize = width / GRID_SIZE;

    // 清空画布
    ctx.clearRect(0, 0, width, height);

    // 绘制棋盘背景
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, width, height);

    // 绘制格子
    for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = 0; col < GRID_SIZE; col++) {
            const x = col * cellSize;
            const y = row * cellSize;

            // 绘制格子背景
            ctx.fillStyle = (row + col) % 2 === 0 ? '#f8fafc' : '#f1f5f9';
            ctx.fillRect(x, y, cellSize, cellSize);

            // 绘制格子边框
            ctx.strokeStyle = 'rgba(124, 58, 237, 0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, cellSize, cellSize);

            // 如果是悬停的格子且是自己的回合，绘制高亮效果
            if (isMyTurn && hoveredCell && hoveredCell.row === row && hoveredCell.col === col) {
                ctx.fillStyle = 'rgba(124, 58, 237, 0.15)';
                ctx.fillRect(x, y, cellSize, cellSize);
            }

            // 绘制棋子
            if (board[row][col]) {
                const piece = board[row][col];
                const padding = cellSize * CELL_PADDING;
                const pieceSize = cellSize - (padding * 2);
                
                // 绘制棋子阴影
                ctx.beginPath();
                ctx.arc(
                    x + cellSize/2 + 2,
                    y + cellSize/2 + 2,
                    (pieceSize/2) * 0.9, // 稍微缩小棋子尺寸
                    0,
                    Math.PI * 2
                );
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.fill();

                // 绘制棋子本体
                ctx.beginPath();
                ctx.arc(
                    x + cellSize/2,
                    y + cellSize/2,
                    (pieceSize/2) * 0.9, // 稍微缩小棋子尺寸
                    0,
                    Math.PI * 2
                );

                // 创建径向渐变作为棋子的基色
                const baseGradient = ctx.createRadialGradient(
                    x + cellSize/2 - pieceSize/4,
                    y + cellSize/2 - pieceSize/4,
                    0,
                    x + cellSize/2,
                    y + cellSize/2,
                    pieceSize/2
                );
                const color = COLORS[piece.color];
                baseGradient.addColorStop(0, color);
                baseGradient.addColorStop(1, adjustColor(color, -20)); // 略微暗化边缘
                ctx.fillStyle = baseGradient;
                ctx.fill();
                
                // 绘制棋子边框
                ctx.strokeStyle = adjustColor(color, -40); // 更暗的边框
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // 添加高光效果
                const highlightGradient = ctx.createRadialGradient(
                    x + cellSize/2 - pieceSize/3,
                    y + cellSize/2 - pieceSize/3,
                    0,
                    x + cellSize/2,
                    y + cellSize/2,
                    pieceSize/2
                );
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                highlightGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = highlightGradient;
                ctx.fill();
            }
        }
    }
}

// 放置棋子
function placePiece(color) {
    if (selectedCell) {
        const piece = { color, scale: 0 };
        board[selectedCell.row][selectedCell.col] = piece;

        function animate() {
            if (piece.scale >= 1) {
                piece.scale = 1;
                drawBoard();
                return;
            }
            piece.scale += 0.1;
            drawBoard();
            requestAnimationFrame(animate);
        }
        animate();
        closeModal();
    }
}

// 移除棋子
function removePiece() {
    if (selectedCell) {
        board[selectedCell.row][selectedCell.col] = null;
        drawBoard();
        closeModal();
    }
}

// 更新玩家数量显示
function updatePlayerCount() {
    const playerCountDiv = document.querySelector('.player-count') || document.createElement('div');
    if (!playerCountDiv.classList.contains('player-count')) {
        playerCountDiv.classList.add('player-count');
        const container = document.querySelector('.game-controls');
        container.appendChild(playerCountDiv);
    }
    playerCountDiv.textContent = `在线玩家: ${playerCount}`;
}

// 事件监听器
canvas.addEventListener('mousemove', (event) => {
    const pos = getBoardPosition(event);
    if (pos.row >= 0 && pos.row < GRID_SIZE && pos.col >= 0 && pos.col < GRID_SIZE) {
        hoveredCell = pos;
    } else {
        hoveredCell = null;
    }
    drawBoard();
});

canvas.addEventListener('click', (event) => {
    if (!isMyTurn) return; // 非自己回合不能操作

    const pos = getBoardPosition(event);
    if (pos.row >= 0 && pos.row < GRID_SIZE && pos.col >= 0 && pos.col < GRID_SIZE) {
        selectedCell = pos;
        showModal();
    }
});

// 添加硬币点击事件
document.querySelector('.coin').addEventListener('click', flipCoin);

// 调整颜色明暗度的辅助函数
function adjustColor(color, amount) {
    const hex = color.replace('#', '');
    const num = parseInt(hex, 16);
    const r = Math.min(255, Math.max(0, (num >> 16) + amount));
    const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));
    const b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));
    return `#${(r << 16 | g << 8 | b).toString(16).padStart(6, '0')}`;
}

// 初始化游戏
function initGame() {
    resizeCanvas();
    initPieceSelector();
    window.addEventListener('resize', resizeCanvas);
    updateTurnButton();
}

// 启动游戏
initGame();
